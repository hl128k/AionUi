name: Background Notarization

# å½“ä¸»æ„å»ºå®Œæˆåè‡ªåŠ¨è§¦å‘ / Triggered automatically after main build completes
on:
  workflow_run:
    workflows: ["Build and Release"]
    types: [completed]
    branches: [main, dev]

  # æ”¯æŒæ‰‹åŠ¨è§¦å‘é‡æ–°å…¬è¯ / Support manual re-notarization
  workflow_dispatch:
    inputs:
      run_id:
        description: 'Build workflow run ID to notarize (leave empty to use latest)'
        required: false
        type: string

jobs:
  notarize:
    # åªåœ¨ä¸»æ„å»ºæˆåŠŸæˆ–æ‰‹åŠ¨è§¦å‘æ—¶è¿è¡Œ / Only run if main build succeeded or manually triggered
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    runs-on: macos-latest
    timeout-minutes: 240  # å¢åŠ åˆ° 240 åˆ†é’Ÿ / Increased to 240 minutes for first-time app notarization

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine workflow run ID
        id: run_id
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # æ‰‹åŠ¨è§¦å‘ï¼šä½¿ç”¨è¾“å…¥çš„ run_id æˆ–æŸ¥æ‰¾æœ€æ–°çš„æˆåŠŸæ„å»º
            if [ -n "${{ inputs.run_id }}" ]; then
              RUN_ID="${{ inputs.run_id }}"
              echo "ğŸ“ Using manually specified run ID: $RUN_ID"
            else
              RUN_ID=$(gh run list --workflow "Build and Release" --status success --limit 1 --json databaseId --jq '.[0].databaseId')
              echo "ğŸ” Using latest successful build run ID: $RUN_ID"
            fi
          else
            # è‡ªåŠ¨è§¦å‘ï¼šä½¿ç”¨è§¦å‘æ­¤ workflow çš„ run_id
            RUN_ID="${{ github.event.workflow_run.id }}"
            echo "ğŸ¤– Using triggering workflow run ID: $RUN_ID"
          fi

          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Download artifacts from main build
        uses: actions/download-artifact@v4
        with:
          name: macos-build
          path: ./artifacts
          run-id: ${{ steps.run_id.outputs.run_id }}
          github-token: ${{ secrets.GH_TOKEN }}

      - name: Check if notarization is needed
        id: check
        run: |
          if [ -f ./artifacts/signing-info.json ]; then
            echo "notarization_needed=true" >> $GITHUB_OUTPUT
            echo "âœ… Found signing-info.json, will proceed with notarization"
          else
            echo "âŒ No signing-info.json found - macOS build likely failed"
            echo "This means the macOS build artifact was not uploaded properly"
            exit 1
          fi

      - name: Extract signing info
        if: steps.check.outputs.notarization_needed == 'true'
        id: info
        run: |
          APP_NAME=$(node -p "require('./artifacts/signing-info.json').appName")
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ App name: $APP_NAME"

      - name: Find DMG file
        if: steps.check.outputs.notarization_needed == 'true'
        id: dmg
        run: |
          # ä» signing-info.json è·å– appName / Get appName from signing-info.json
          APP_NAME=$(node -p "require('./artifacts/signing-info.json').appName")

          # ä½¿ç”¨ appName ç²¾ç¡®åŒ¹é… DMG / Use appName to match DMG precisely
          DMG_FILE=$(ls ./artifacts/${APP_NAME}*.dmg 2>/dev/null | head -1)

          if [ -z "$DMG_FILE" ]; then
            echo "âŒ No DMG file found matching pattern: ${APP_NAME}*.dmg"
            echo "Available files in artifacts:"
            ls -la ./artifacts/
            exit 1
          fi

          DMG_COUNT=$(ls ./artifacts/${APP_NAME}*.dmg 2>/dev/null | wc -l)
          if [ "$DMG_COUNT" -gt 1 ]; then
            echo "âš ï¸  Warning: Multiple DMG files found, using first one:"
            ls ./artifacts/${APP_NAME}*.dmg
          fi

          echo "dmg_path=$DMG_FILE" >> $GITHUB_OUTPUT
          echo "âœ… Found DMG: $DMG_FILE"

      - name: Extract and compress app for notarization
        if: steps.check.outputs.notarization_needed == 'true'
        id: compress
        run: |
          DMG_PATH="${{ steps.dmg.outputs.dmg_path }}"
          APP_NAME=$(node -p "require('./artifacts/signing-info.json').appName")

          echo "ğŸ“¦ Mounting DMG..."
          MOUNT_POINT=$(hdiutil attach "$DMG_PATH" -nobrowse -readonly | tail -1 | awk '{print $3}')

          if [ -z "$MOUNT_POINT" ]; then
            echo "âŒ Failed to mount DMG"
            exit 1
          fi

          echo "âœ… DMG mounted at: $MOUNT_POINT"

          # æŸ¥æ‰¾ .app æ–‡ä»¶
          APP_PATH=$(find "$MOUNT_POINT" -name "${APP_NAME}.app" -maxdepth 2 | head -1)

          if [ -z "$APP_PATH" ]; then
            echo "âŒ .app not found in DMG"
            hdiutil detach "$MOUNT_POINT" -force || true
            exit 1
          fi

          echo "âœ… Found app: $APP_PATH"

          # ä½¿ç”¨ ditto å‹ç¼©ï¼ˆApple æ¨èæ–¹å¼ï¼‰
          ZIP_PATH="./artifacts/${APP_NAME}.zip"
          echo "ğŸ“¦ Compressing app to ZIP..."
          ditto -c -k --keepParent "$APP_PATH" "$ZIP_PATH"

          # å¸è½½ DMG
          hdiutil detach "$MOUNT_POINT" -force || true

          # æ£€æŸ¥ ZIP å¤§å°
          DMG_SIZE=$(ls -lh "$DMG_PATH" | awk '{print $5}')
          ZIP_SIZE=$(ls -lh "$ZIP_PATH" | awk '{print $5}')

          echo "âœ… Compression complete!"
          echo "   DMG size: $DMG_SIZE"
          echo "   ZIP size: $ZIP_SIZE"

          echo "zip_path=$ZIP_PATH" >> $GITHUB_OUTPUT

      - name: Submit for notarization with improved timeout handling
        if: steps.check.outputs.notarization_needed == 'true'
        id: submit
        run: |
          ZIP_PATH="${{ steps.compress.outputs.zip_path }}"
          MAX_RETRIES=3
          RETRY_DELAY=300  # 5åˆ†é’Ÿ / 5 minutes
          
          # For first-time apps, Apple may take longer than typical 60min
          NOTARIZATION_TIMEOUT=90m  # Increased to 90 minutes for first-time submissions
          
          # Try notarization submission
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸš€ Notarization attempt $attempt/$MAX_RETRIES"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“¦ Submitting ZIP: $ZIP_PATH"
            echo "â° Timeout: $NOTARIZATION_TIMEOUT"
            echo "ğŸ“‹ This may take a very long time (up to 24 hours) for first-time apps"
            
            # ä¼˜å…ˆä½¿ç”¨ API Key / Prefer API Key if available (more reliable than Apple ID)
            if [ -n "${{ secrets.APPLE_API_KEY }}" ]; then
              echo "ğŸ”‘ Using API Key authentication (recommended)"
              echo "${{ secrets.APPLE_API_KEY }}" | base64 -d > /tmp/authkey.p8

              # Submit without --wait to avoid blocking, get submission ID for polling
              SUBMIT_RESULT=$(xcrun notarytool submit "$ZIP_PATH" \
                --key /tmp/authkey.p8 \
                --key-id "${{ secrets.APPLE_API_KEY_ID }}" \
                --issuer "${{ secrets.APPLE_API_ISSUER }}" \
                --output-format json 2>&1)
              SUBMIT_STATUS=$?

              rm -f /tmp/authkey.p8
            else
              echo "ğŸ”‘ Using Apple ID authentication"
              
              # Submit without --wait to avoid blocking, get submission ID for polling
              SUBMIT_RESULT=$(xcrun notarytool submit "$ZIP_PATH" \
                --apple-id "${{ secrets.APPLE_ID }}" \
                --password "${{ secrets.APPLE_ID_PASSWORD }}" \
                --team-id "${{ secrets.TEAM_ID }}" \
                --output-format json 2>&1)
              SUBMIT_STATUS=$?
            fi

            if [ $SUBMIT_STATUS -eq 0 ]; then
              SUBMISSION_ID=$(echo "$SUBMIT_RESULT" | grep -o '"id": *"[^"]*"' | head -1 | grep -o '"[^"]*"$' | tr -d '"')
              if [ -n "$SUBMISSION_ID" ]; then
                echo "âœ… Notarization submitted successfully! ID: $SUBMISSION_ID"
                
                # Now poll for completion with improved timeout handling
                echo "â³ Waiting for notarization to complete (ID: $SUBMISSION_ID)..."
                echo "â° This may take up to 24 hours for first-time app submissions"
                
                # Use exponential backoff for polling: start with 30s, max 10min intervals
                POLL_INTERVAL=30
                MAX_POLL_INTERVAL=600  # 10 minutes max
                TOTAL_POLL_TIME=0
                MAX_POLL_TIME=86400  # 24 hours max total wait time (Apple can take this long for first-time apps)
                LAST_STATUS=""
                
                while [ $TOTAL_POLL_TIME -lt $MAX_POLL_TIME ]; do
                  # Check status without waiting, with better error handling
                  if [ -n "${{ secrets.APPLE_API_KEY }}" ]; then
                    # Use API key if available
                    echo "${{ secrets.APPLE_API_KEY }}" | base64 -d > /tmp/authkey.p8
                    STATUS_RESULT=$(xcrun notarytool info "$SUBMISSION_ID" \
                      --key /tmp/authkey.p8 \
                      --key-id "${{ secrets.APPLE_API_KEY_ID }}" \
                      --issuer "${{ secrets.APPLE_API_ISSUER }}" \
                      --output-format json 2>&1)
                    STATUS_CODE=$?
                    rm -f /tmp/authkey.p8
                  else
                    # Fallback to Apple ID
                    STATUS_RESULT=$(xcrun notarytool info "$SUBMISSION_ID" \
                      --output-format json \
                      --apple-id "${{ secrets.APPLE_ID }}" \
                      --password "${{ secrets.APPLE_ID_PASSWORD }}" \
                      --team-id "${{ secrets.TEAM_ID }}" 2>&1)
                    STATUS_CODE=$?
                  fi
                  
                  if [ $STATUS_CODE -eq 0 ]; then
                    STATUS=$(echo "$STATUS_RESULT" | grep -o '"status": *"[^"]*"' | head -1 | grep -o '"[^"]*"$' | tr -d '"')
                    
                    # Only log status if it has changed to reduce log spam
                    if [ "$STATUS" != "$LAST_STATUS" ]; then
                      echo "ğŸ“Š Status: $STATUS (after $((TOTAL_POLL_TIME/60)) minutes)"
                      LAST_STATUS="$STATUS"
                    elif [ $((TOTAL_POLL_TIME % 600)) -eq 0 ]; then
                      # Log every 10 minutes even if status hasn't changed
                      echo "ğŸ“Š Status: $STATUS (still processing, total elapsed: $((TOTAL_POLL_TIME/60)) minutes)"
                    fi
                    
                    case "$STATUS" in
                      "Accepted")
                        echo "âœ… Notarization completed successfully!"
                        echo "submission_id=$SUBMISSION_ID" >> $GITHUB_OUTPUT
                        echo "status=$STATUS" >> $GITHUB_OUTPUT
                        exit 0
                        ;;
                      "Invalid"|"Rejected")
                        echo "âŒ Notarization failed with status: $STATUS"
                        echo "$STATUS_RESULT"
                        # Get detailed logs for debugging
                        if [ -n "${{ secrets.APPLE_API_KEY }}" ]; then
                          echo "${{ secrets.APPLE_API_KEY }}" | base64 -d > /tmp/authkey.p8
                          xcrun notarytool log "$SUBMISSION_ID" \
                            --key /tmp/authkey.p8 \
                            --key-id "${{ secrets.APPLE_API_KEY_ID }}" \
                            --issuer "${{ secrets.APPLE_API_ISSUER }}" 2>&1 || true
                          rm -f /tmp/authkey.p8
                        else
                          xcrun notarytool log "$SUBMISSION_ID" \
                            --apple-id "${{ secrets.APPLE_ID }}" \
                            --password "${{ secrets.APPLE_ID_PASSWORD }}" \
                            --team-id "${{ secrets.TEAM_ID }}" 2>&1 || true
                        fi
                        exit 1
                        ;;
                      *)
                        # Continue waiting
                        ;;
                    esac
                  else
                    # Handle network errors or API issues gracefully
                    echo "âš ï¸  Failed to check notarization status: $STATUS_RESULT"
                    echo "â° Continuing to wait (network issue or temporary API problem)"
                  fi
                  
                  # Wait before next check
                  sleep $POLL_INTERVAL
                  TOTAL_POLL_TIME=$((TOTAL_POLL_TIME + POLL_INTERVAL))
                  
                  # Exponential backoff for polling interval (max 10 minutes)
                  if [ $POLL_INTERVAL -lt $MAX_POLL_INTERVAL ]; then
                    POLL_INTERVAL=$((POLL_INTERVAL * 2))
                    if [ $POLL_INTERVAL -gt $MAX_POLL_INTERVAL ]; then
                      POLL_INTERVAL=$MAX_POLL_INTERVAL
                    fi
                  fi
                done
                
                echo "â° Max wait time reached ($((MAX_POLL_TIME/3600)) hours), notarization still in progress"
                echo "This is expected for first-time submissions which can take up to 24 hours"
                echo "Try again later or check the status manually using:"
                echo "  xcrun notarytool info $SUBMISSION_ID --apple-id '${{ secrets.APPLE_ID }}' --team-id '${{ secrets.TEAM_ID }}'"
                echo "Notarization was submitted successfully but timed out waiting for completion"
                exit 1
              else
                echo "âš ï¸  Failed to extract submission ID, result: $SUBMIT_RESULT"
              fi
            else
              echo "âš ï¸  Notarization submission failed on attempt $attempt:"
              echo "$SUBMIT_RESULT"
            fi

            # å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç­‰å¾…åé‡è¯• / If not last attempt, wait and retry
            if [ $attempt -lt $MAX_RETRIES ]; then
              echo "â³ Waiting $RETRY_DELAY seconds before retry..."
              sleep $RETRY_DELAY
            fi
          done

          # æ‰€æœ‰å°è¯•éƒ½å¤±è´¥ / All attempts failed
          echo ""
          echo "âŒ Notarization failed after $MAX_RETRIES attempts"
          echo "Last result: $SUBMIT_RESULT"
          exit 1

      - name: Staple notarization ticket
        if: steps.check.outputs.notarization_needed == 'true' && steps.submit.outputs.status == 'Accepted'
        run: |
          echo "ğŸ“ Stapling notarization ticket..."
          xcrun stapler staple "${{ steps.dmg.outputs.dmg_path }}"
          echo "âœ… Stapling complete!"

      - name: Verify notarization
        if: steps.check.outputs.notarization_needed == 'true' && steps.submit.outputs.status == 'Accepted'
        run: |
          echo "ğŸ” Verifying notarization..."
          xcrun stapler validate "${{ steps.dmg.outputs.dmg_path }}"
          spctl -a -vvv -t install "${{ steps.dmg.outputs.dmg_path }}"
          echo "âœ… Verification successful!"

      - name: Get release info
        if: steps.check.outputs.notarization_needed == 'true' && steps.submit.outputs.status == 'Accepted'
        id: release
        run: |
          # ä» signing-info.json è¯»å– release tag / Read release tag from signing-info.json
          RELEASE_TAG=$(node -p "require('./artifacts/signing-info.json').releaseTag || ''")

          if [ -z "$RELEASE_TAG" ]; then
            echo "âŒ No release tag found in signing-info.json"
            echo "This means the release job did not update signing-info.json properly"
            echo "Artifact contents:"
            ls -la ./artifacts/
            cat ./artifacts/signing-info.json
            exit 1
          fi

          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "âœ… Target release: $RELEASE_TAG"
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Upload notarized DMG to release
        if: steps.check.outputs.notarization_needed == 'true' && steps.submit.outputs.status == 'Accepted'
        run: |
          DMG_NAME=$(basename "${{ steps.dmg.outputs.dmg_path }}")

          echo "ğŸš€ Uploading notarized DMG to release..."

          # åˆ é™¤æ—§çš„ DMGï¼ˆå¦‚æœå­˜åœ¨ï¼‰/ Delete old DMG if exists
          gh release delete-asset "${{ steps.release.outputs.release_tag }}" "$DMG_NAME" --yes || true

          # ä¸Šä¼ æ–°çš„å…¬è¯è¿‡çš„ DMG / Upload new notarized DMG
          gh release upload "${{ steps.release.outputs.release_tag }}" "${{ steps.dmg.outputs.dmg_path }}" --clobber

          echo "âœ… Notarized DMG uploaded successfully!"
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Add notarization success comment
        if: steps.check.outputs.notarization_needed == 'true' && steps.submit.outputs.status == 'Accepted'
        run: |
          gh release edit "${{ steps.release.outputs.release_tag }}" --notes-file - <<EOF
          $(gh release view "${{ steps.release.outputs.release_tag }}" --json body --jq '.body')

          ---

          âœ… **macOS App Notarized** ($(date -u +"%Y-%m-%d %H:%M:%S UTC"))

          The macOS DMG has been successfully notarized by Apple and is now fully verified for distribution.
          EOF
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}

      - name: Notify on failure
        if: failure()
        run: |
          echo "âŒ Background notarization failed"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ“¦ Current Status:"
          echo "   â€¢ Signed DMG is available in the release"
          echo "   â€¢ Users can install by right-clicking and selecting 'Open'"
          echo "   â€¢ Notarization failed - DMG is not fully verified"
          echo ""
          echo "ğŸ”„ How to Retry:"
          echo "   1. Go to Actions â†’ Background Notarization"
          echo "   2. Click 'Run workflow'"
          echo "   3. Leave run_id empty to retry latest build"
          echo "   4. Or specify the build run ID"
          echo ""
          echo "ğŸ• Typical Causes:"
          echo "   â€¢ Apple notarization service timeout (> 24 hours for first-time apps)"
          echo "   â€¢ Apple service temporarily unavailable"
          echo "   â€¢ Network connectivity issues"
          echo "   â€¢ Invalid code signing"
          echo ""
          echo "ğŸ’¡ First-time apps can take up to 24 hours for initial notarization"
          echo "   Subsequent builds typically take 5-15 minutes"
          echo ""
          echo "ğŸ’¡ Workflow URL:"
          echo "   https://github.com/${{ github.repository }}/actions/workflows/notarize-background.yml"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"